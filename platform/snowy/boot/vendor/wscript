def configure(conf):
    conf.env.append_unique('DEFINES', 'STM32F429_439xx')

def build(bld):
    # Define paths relative to the project root (assuming wscript is 4 levels down)
    proj_root = bld.path.parent.parent.parent.parent

    hal_stm32_path = proj_root.find_node('third_party/hal_stm32/stm32-sdk')
    cmsis_core_path = proj_root.find_node('third_party/cmsis_core/CMSIS/CMSIS/Core')

    # Check if paths were found
    if not hal_stm32_path:
        bld.fatal("Could not find third_party/hal_stm32/stm32-sdk")
    if not cmsis_core_path:
        bld.fatal("Could not find third_party/cmsis_core/CMSIS/CMSIS/Core")

    # Source files: Only StdPeriph Driver sources seem needed now
    stm32_srcdir = hal_stm32_path.find_node('STM32F4xx_StdPeriph_Driver/src')
    if not stm32_srcdir:
        bld.fatal("Could not find STM32F4xx_StdPeriph_Driver/src")

    stm32_sources = stm32_srcdir.ant_glob('*.c', excl=['stm32f4xx_fsmc.c'])

    # Include paths
    stm32_includes = [
        cmsis_core_path.find_node('Include'),
        hal_stm32_path.find_node('Device/ST/STM32F4xx/Include'),
        hal_stm32_path.find_node('STM32F4xx_StdPeriph_Driver/inc'),
    ]

    # Filter out None values in case some paths weren't found (though fatal checks handle this)
    stm32_includes = [p for p in stm32_includes if p]

    bld.stlib(source=stm32_sources,
              target='stm32_stdlib',
              includes=[p.path_from(bld.path) for p in stm32_includes], # Use relative paths for includes
              export_includes=[p.path_from(bld.path) for p in stm32_includes]) # Use relative paths for export_includes

# vim:filetype=python
